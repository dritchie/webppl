var params = require.call(null, 'vpf_experiments/targetsum/params');
var tempSchedules = require.call(null, 'src/tempSchedules');
var bounds = require.call(null, 'src/bounds');

var targetsum = 10;
// var tightness = 0.1;
var tightness = 1;

var vparams = VPF.newParams();

// var _gaussian = gaussian;
var _gaussian = function(mu, sigma, prevs) {
	// var prms = params.gaussianParams(vparams, prevs.length, prevs);
	var prms = params.generalParams(vparams, prevs.length, [bounds.none, bounds.nonNegative], prevs);
	VPF.gaussianERP.importanceERP.setParams(prms);
	return sample(VPF.gaussianERP, [mu, sigma]);
}

var program = function() {
	var x1 = _gaussian(0, 5, []);
	var x2 = _gaussian(0, 5, [x1]);
	var x3 = _gaussian(0, 5, [x1, x2]);
	var sum = x1 + x2 + x3;
	factor(gaussianERP.score([targetsum, tightness], sum));
	return [x1, x2, x3];
}

var result = VPF(program, {
	numParticles: 100,
	maxNumFlights: 1000,
	vparams: vparams,
	convergeEps: 0.1,
	adagradInitLearnRate: 1,
	// tempSchedule: tempSchedules.linear,

	doResampling: false,
	objective: 'ELBO',

	verbosity: {
		flightNum: true,
		scoreDiff: true,
		// particleNum: true,
		// params: true,
		// gradientEstimate: true,
		// gradientSamples: true,
		endStatus: true
	}
});

console.log(result.finalParams);

repeat(10, function() {
	var result = ParticleFilter(program, 1);
	var nums = result.MAP().val;
	console.log((nums[0]+nums[1]+nums[2]) + ': ' + JSON.stringify(nums));
});

undefined;