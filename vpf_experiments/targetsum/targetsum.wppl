var params = require.call(null, 'vpf_experiments/targetsum/params');
var tempSchedules = require.call(null, 'src/tempSchedules');

var vparams = VPF.newParams();

// var _gaussian = gaussian;
var _gaussian = function(mu, sigma, prevs) {
	// var prms = params.gaussianParams(vparams, prevs.length, prevs);
	var prms = params.generalParams(vparams, prevs.length, prevs);
	VPF.gaussianERP.importanceERP.setParams(prms);
	return sample(VPF.gaussianERP, [mu, sigma]);
}

var nVars = 10;
var targetsum = 10 * nVars / 3;
var tightness = targetsum / 10;
// var tightness = 1;

var genvars = function(prevVars) {
	if (prevVars.length === nVars) {
		return prevVars;
	} else {
		var x = _gaussian(0, 5, prevVars);
		return genvars(prevVars.concat([x]));
	}
}

var program = function() {
	var vars = genvars([]);
	var sumvars = sum(vars);
	factor(gaussianERP.score([targetsum, tightness], sumvars));
	return vars;
}

var result = VPF(program, {
	numParticles: 100,
	maxNumFlights: 1000,
	vparams: vparams,
	convergeEps: 0.1,
	adagradInitLearnRate: 1,
	// tempSchedule: tempSchedules.linear,

	doResampling: false,
	objective: 'ELBO',

	verbosity: {
		flightNum: true,
		scoreDiff: true,
		// particleNum: true,
		// params: true,
		// gradientEstimate: true,
		// gradientSamples: true,
		endStatus: true
	}
});

console.log(result.finalParams);

console.log('target sum: ' + targetsum);
repeat(10, function() {
	var nums = ParticleFilter(program, 1).MAP().val;
	console.log(sum(nums) + ': ' + JSON.stringify(nums));
});

undefined;