var THREE = require.call(null, 'three');
var lsysParams = require.call(null, 'vpf_experiments/lsystem/params.js');
var lsysUtils = require.call(null, 'vpf_experiments/lsystem/utils.js');
var bounds = require.call(null, 'src/bounds');
var utils = require.call(null, 'vpf_experiments/utils.js');

var vec2 = function(x, y) {
	var v = Object.create(THREE.Vector2.prototype);
	THREE.Vector2.call(v, x, y);
	return v;
}

var box2 = function() {
	var b = Object.create(THREE.Box2.prototype);
	THREE.Box2.call(b);
	return b;
}

var polar2rect = function(r, theta) {
	return vec2(r*Math.cos(theta), r*Math.sin(theta));
}


var viewport = {xmin: -12, xmax: 12, ymin: -22, ymax: 2};


// var targetName = 'curl';
// var targetName = 'bifurcate';
// var targetName = 'a';
// var targetName = 'heart';
// var targetName = 'manybranch_3';
// var targetName = 'manybranch_4';
// var targetName = 'manybranch_7';
// var targetName = 'snake_3';
// var targetName = 'spiral';
var targetName = 't';

var targetDB = lsysUtils.newTargetImageDatabase('vpf_experiments/lsystem/targets/training');
globalStore.target = targetDB.getTargetByName(targetName);


// Compute normalized similarity for a set of branches
var computeSim = function(branches, inInference) {
	var target = globalStore.target;
	// If not in inference, just render everything
	if (!inInference) {
		lsysUtils.render(target.canvas, viewport, branches);
	// Otherwise, do an incremental render of the last branch
	} else {
		if (globalStore.genImg !== undefined) {
			globalStore.genImg.copyToCanvas(target.canvas);
		}
		lsysUtils.render(target.canvas, viewport, branches, true, globalStore.genImg === undefined);
	}
	globalStore.genImg = lsysUtils.newImageData2D().loadFromCanvas(target.canvas);
	return lsysUtils.normalizedSimilarity(globalStore.genImg, globalStore.target);
};

// Basically Gaussian log-likelihood, without the constant factor
var makescore = function(val, target, tightness) {
	var diff = val - target;
	return - (diff * diff) / (tightness * tightness);
}

var simTightness = 0.02;
// var simTightness = 0.05;
var boundsTightness = 0.001;
var availableFuturesWeight = 25;
var targetFactor = function() {
	// Similarity factor
	var sim = computeSim(globalStore.branches, true);
	globalStore.sim = sim;
	var simf = makescore(sim, 1, simTightness);
	// Bounds factors
	var bbox = globalStore.bbox;
	var extraX = (Math.max(viewport.xmin - bbox.min.x, 0) + Math.max(bbox.max.x - viewport.xmax, 0)) / (viewport.xmax - viewport.xmin);
	var extraY = (Math.max(viewport.ymin - bbox.min.y, 0) + Math.max(bbox.max.y - viewport.ymax, 0)) / (viewport.ymax - viewport.ymin);
	var boundsfx = makescore(extraX, 0, boundsTightness);
	var boundsfy = makescore(extraY, 0, boundsTightness);
	// var f = simf + boundsfx + boundsfy;
	////
	// More available futures factor
	var fprime = simf + boundsfx + boundsfy;
	var f = fprime + availableFuturesWeight*availableFuturesScore();
	////
	if (globalStore.prevFactor) {
		factor(f - globalStore.prevFactor);
	} else {
		factor(f);
	}
	globalStore.prevFactor = f;
};



var vparams = Variational.newParams();


// setFuturePolicy('lifo');
// setFuturePolicy('fifo');
setFuturePolicy('uniformFromAll');
// setFuturePolicy('uniformFromDeepest');
// setFuturePolicy('depthWeighted');


var makeProgram = function(variational, doFactors) {

	var initialWidth = 0.75;
	var widthDecay = 0.975;
	var minWidthPercent = 0.2;

	// var _gaussian = gaussian;
	var _gaussian = !variational ? gaussian :
	function(mu, sigma) {
		var addr = currentAddress();
		var callsite = addr.slice(addr.lastIndexOf('_'));
		var bnds = [bounds.none, bounds.nonNegative];
		var features = globalStore.currFeatures;
		var origprms = [mu, sigma];
		var params = lsysParams.get(vparams, callsite, origprms, bnds, features);
		Variational.gaussianERP.importanceERP.setParams(params);
		return sample(Variational.gaussianERP, origprms);
	};

	// var _flip = flip;
	var _flip = !variational ? flip :
	function(p) {
		var addr = currentAddress();
		var callsite = addr.slice(addr.lastIndexOf('_'));
		var bnds = [bounds.unitInterval];
		var features = globalStore.currFeatures;
		var origprms = [p];
		var params = lsysParams.get(vparams, callsite, origprms, bnds, features);
		Variational.bernoulliERP.importanceERP.setParams(params);
		return sample(Variational.bernoulliERP, origprms);
	};


	var fuzz = [0, 1e-8];
	var normalize = function(x, lo, hi) {
		// Fuzz prevents values from normalizing to zero and causing zero derivatives.
		// Also might make learning a bit more robust(?)
		return (2 * (x - lo) / (hi - lo)) - 1 + gaussianERP.sample(fuzz);
		// return (x - lo) / (hi - lo) + gaussianERP.sample(fuzz);
	};
	var TWOPI = 2*Math.PI;
	var normang = function(theta) {
		if (theta >= 0) {
			return theta - (TWOPI*Math.floor(theta / TWOPI));
		} else {
			return theta - (TWOPI*Math.ceil(theta / TWOPI)) + TWOPI;
		}
	};
	var setCurrFeatures = function(currState) {
		var x = normalize(currState.pos.x, viewport.xmin, viewport.xmax);
		var y = normalize(currState.pos.y, viewport.ymin, viewport.ymax);
		var depth = normalize(currState.depth, 0, 5);
		var ang = normalize(normang(currState.angle), 0, TWOPI);
		globalStore.currFeatures = [x, y, depth, ang];
	};

	var branch = function(currState) {
		setCurrFeatures(currState);

		// Generate new branch
		var width = widthDecay * currState.width;
		var length = 2;
		var newang = currState.angle + _gaussian(0, Math.PI/8);	
		var newbranch = {
			start: currState.pos,
			angle: newang,
			width: width,
			end: currState.pos.clone().add(polar2rect(length, newang))
		};

		// Update model state
		globalStore.branches = { branch: newbranch, next: globalStore.branches };
		globalStore.numBranches = globalStore.numBranches + 1;
		globalStore.bbox = globalStore.bbox.clone();
		globalStore.bbox.expandByPoint(newbranch.start);
		globalStore.bbox.expandByPoint(newbranch.end);

		// Add new heuristic factor
		if (doFactors) targetFactor();

		var newState = {
			depth: currState.depth + 1,
			pos: newbranch.end,
			angle: newbranch.angle,
			width: newbranch.width
		};

		// Terminate?
		future(function() {
			var terminateProb = 0.5;
			if (_flip(terminateProb)) {
				globalStore.terminated = true;
			} else {
				// Generate no further branches w/ prob 1/3
				// Generate one further branch w/ prob 1/3
				// Generate two further branches w/ prob 1/3
				future(function() {
					if (!globalStore.terminated && newState.width/initialWidth > minWidthPercent && _flip(0.66)) {
						branch(newState);
						future(function() {
							if (!globalStore.terminated && newState.width/initialWidth > minWidthPercent && _flip(0.5)) {
								branch(newState);
							}
						});
					}
				});
				// future(function() {
				// 	if (!globalStore.terminated && newState.width/initialWidth > minWidthPercent && _flip(0.5)) {
				// 		branch(newState);
				// 	}
				// });
				// future(function() {
				// 	if (!globalStore.terminated && newState.width/initialWidth > minWidthPercent && _flip(0.5)) {
				// 		branch(newState);
				// 	}
				// });
			}
		});
	};

	var generate = function() {
		// If target is not fixed, then marginalize over targets
		if (globalStore.target === undefined) {
			globalStore.target = targetDB.getTargetByIndex(randomInteger(targetDB.numTargets()));
		}
		globalStore.branches = undefined;
		globalStore.numBranches = 0;
		globalStore.bbox = box2();
		globalStore.currFeatures = [];
		var startState = {
			depth: 0,
			pos: vec2(0, 0),
			angle: _gaussian(-Math.PI/2, Math.PI/6),
			width: initialWidth
		};
		future(function() { branch(startState); });
		finishAllFutures();
		return globalStore.branches;
	};

	return generate;
}


var testRun = function() {

	var variational = false;
	var doFactors = true;
	var generate = makeProgram(variational, doFactors);

	var useSavedParams = false;
	var saveParams = false;
	// var paramFile = 'vpf_experiments/lsystem/saved_params/' + targetName + '.txt';
	var paramFile = 'vpf_experiments/lsystem/saved_params/' + targetName + '_eubo.txt';

	if (variational) {
		if (!useSavedParams) {
			Variational(generate, vparams, {
				numParticles: 100,
				maxNumFlights: 1000,
				// convergeEps: 0.1,
				convergeEps: 0.01,
				adagradInitLearnRate: 0.25,
				// adagradInitLearnRate: 0.1,
				// adagradInitLearnRate: 0.05,

				// gradientEstimator: 'ELBO',
				gradientEstimator: 'EUBO',
				exampleTraces: utils.loadTraces('vpf_experiments/lsystem/data/' + targetName + '.txt'),

				verbosity: {
					flightNum: true,
					scoreDiff: true,
					endStatus: true
				}
			});
			if (saveParams) {
				Variational.saveParams(vparams, paramFile);
			}
		} else {
			Variational.loadParams(vparams, paramFile);
		}
	}

	var res = {width: 600, height: 600};
	var n = 10;
	var skip = 1;
	var name = 'test';
	var resultsDir = 'vpf_experiments/lsystem/results/image/' + name;
	var fs = require.call(null, 'fs');
	if (!fs.existsSync(resultsDir)) {
		fs.mkdirSync(resultsDir);
	}
	var sims = repeat(n, function(i) {
		// var nParticles = 1;
		var nParticles = 300;
		var ret = sample(ParticleFilter(generate, nParticles));
		var sim = computeSim(ret);
		console.log(i + ' | sim: ' + sim);
		if (i % skip === 0) {
			lsysUtils.renderOut(resultsDir + '/' + (i/skip) + '.png', res, viewport, ret);
		}
		return sim;
	});
	console.log('sim -  min: ' + listMin(sims) + ', max: ' + listMax(sims) +
		               ', avg: ' + listMean(sims) + ', stddev: ' + listStdev(sims));
}


var generateTrainingData = function(name) {
	var dataDir = 'vpf_experiments/lsystem/data';
	var fs = require.call(null, 'fs');
	if (!fs.existsSync(dataDir)) {
		fs.mkdirSync(dataDir);
	}
	var filename = dataDir + '/' + name + '.txt';
	var genFn = makeProgram(false, true);
	var genData = function(counter) {
		var trace = ParticleFilter(genFn, 300).trace;
		fs.appendFileSync(filename, JSON.stringify(trace) + '\n');
		console.log('Generated trace ' + counter);
		genData(counter + 1);
	}
	genData(0);
};


var compareVariationalToPrior = function(paramFile) {
	var present = { present: require.call(null, 'present') };	// For timing
	var util = require.call(null, 'util');
	var outfilename = targetName + '_comparison.csv';
	var outfile = fs.openSync('vpf_experiments/lsystem/experiment_results/image/'+outfilename, 'w');
	fs.writeSync(outfile, 'isVariational,numParticles,sim,time,avgTime\n');
	var nReps = 100;
	map(function(isVariational) {
		console.log('isVariational = ' + isVariational);
		var genFn = makeProgram(isVariational, true);
		if (isVariational) Variational.loadParams(vparams, paramFile);
		repeat(10, function(np) {
			var nParticles = np + 1;
			console.log('  nParticles = ' + nParticles);
			var simsAndTimes = repeat(nReps, function(i) {
				console.log('    repetition ' + i);
				var t0 = present.present();
				var ret = sample(ParticleFilter(genFn, nParticles));
				var t1 = present.present();
				var time = t1 - t0;
				var sim = computeSim(ret);
				return [sim, time];
			});
			var times = map(function(st) { return st[1]; }, simsAndTimes);
			var avgTime = sum(times) / times.length;
			map(function(st) {
				fs.writeSync(outfile, util.format('%s,%d,%d,%d,%d\n',
					isVariational, nParticles, st[0], st[1], avgTime));
			}, simsAndTimes);
		});
	}, [false, true]);
	fs.closeSync(outfile);
}


var serverReponse = function() {
	var particleHistoryUtils = require.call(null, 'vpf_experiments/lsystem/particleHistoryUtils');
	var saveHistory = lsysUtils.deleteStoredImages;
	// var saveHistory = false;
	var nParticles = 300;
	// var nParticles = 3000;
	var genFn = makeProgram(false, true);
	// var genFn = makeProgram(true, true);
	// Variational.loadParams(vparams, 'vpf_experiments/lsystem/saved_params/curl_eubo.txt');
	var dist = ParticleFilter(genFn, nParticles, true, saveHistory);

	return {
		targetName: targetName,
		viewport: viewport,
		history: particleHistoryUtils.compress(dist.particleHistory)
	};
}



// testRun();
// generateTrainingData(targetName);
// compareVariationalToPrior('vpf_experiments/lsystem/saved_params/curl_eubo.txt');
serverReponse();





