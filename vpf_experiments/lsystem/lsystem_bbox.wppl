var THREE = require.call(null, 'three');
var lsysParams = require.call(null, 'vpf_experiments/lsystem/params.js');
var lsysUtils = require.call(null, 'vpf_experiments/lsystem/utils.js');
var bounds = require.call(null, 'src/bounds');
var utils = require.call(null, 'vpf_experiments/utils.js');
var fs = require.call(null, 'fs');

var vec2 = function(x, y) {
	var v = Object.create(THREE.Vector2.prototype);
	THREE.Vector2.call(v, x, y);
	return v;
}

var box2 = function() {
	var b = Object.create(THREE.Box2.prototype);
	THREE.Box2.call(b);
	return b;
}

var polar2rect = function(r, theta) {
	return vec2(r*Math.cos(theta), r*Math.sin(theta));
}


var viewport = {xmin: -12, xmax: 12, ymin: -22, ymax: 2};



var vparams = Variational.newParams();




var makeProgram = function(opts) {

	var variational = opts.variational === undefined ? false : opts.variational;
	var heuristicFactors = opts.heuristicFactors === undefined ? false : opts.heuristicFactors;
	var futurePolicy = opts.futurePolicy || 'deterministic';

	var targetFactor = function(mult) {
		var tw = globalStore.targetWidth;
		var twt = globalStore.targetWidthTightness;
		var size = globalStore.bbox.size();
		// var f = gaussianERP.score([tw, twt], size.x);
		var f = -((size.x - tw) * (size.x - tw)) / (twt * twt);
		factor(mult * f);
	}

	// var _gaussian = gaussian;
	var _gaussian = !variational ? gaussian :
	function(mu, sigma) {
		var addr = currentAddress();
		var callsite = addr.slice(addr.lastIndexOf('_'));
		var bnds = [bounds.none, bounds.nonNegative];
		var features = globalStore.currFeatures;
		var origprms = [mu, sigma];
		var params = lsysParams.get(vparams, callsite, origprms, bnds, features);
		Variational.gaussianERP.importanceERP.setParams(params);
		return sample(Variational.gaussianERP, origprms);
	};

	// var _uniform = uniform;
	var _uniform = !variational ? uniform :
	function(lo, hi) {
		var addr = currentAddress();
		var callsite = addr.slice(addr.lastIndexOf('_'));
		var bnds = [bounds.nonNegative, bounds.nonNegative];
		var features = globalStore.currFeatures;
		var origprms = [1, 1];
		var params = lsysParams.get(vparams, callsite, origprms, bnds, features);
		Variational.betaERP.importanceERP.setParams(params);
		var t = sample(Variational.betaERP, origprms);
		return (1-t)*lo + t*hi;
	};

	// var _flip = flip;
	var _flip = !variational ? flip :
	function(p) {
		var addr = currentAddress();
		var callsite = addr.slice(addr.lastIndexOf('_'));
		var bnds = [bounds.unitInterval];
		var features = globalStore.currFeatures;
		var origprms = [p];
		var params = lsysParams.get(vparams, callsite, origprms, bnds, features);
		Variational.bernoulliERP.importanceERP.setParams(params);
		return sample(Variational.bernoulliERP, origprms);
	}


	var fuzz = [0, 1e-8];
	var normalize = function(x, lo, hi) {
		// Fuzz prevents values from normalizing to zero and causing zero derivatives.
		// Also might make learning a bit more robust(?)
		return (2 * (x - lo) / (hi - lo)) - 1 + gaussianERP.sample(fuzz);
		// return (x - lo) / (hi - lo) + gaussianERP.sample(fuzz);
	}
	var TWOPI = 2*Math.PI;
	var normang = function(theta) {
		if (theta >= 0) {
			return theta - (TWOPI*Math.floor(theta / TWOPI));
		} else {
			return theta - (TWOPI*Math.ceil(theta / TWOPI)) + TWOPI;
		}
	}
	var setCurrFeatures = function(currState) {
		var x = normalize(currState.pos.x, viewport.xmin, viewport.xmax);
		var y = normalize(currState.pos.y, viewport.ymin, viewport.ymax);
		var depth = normalize(currState.depth, 0, 5);
		var sang = Math.sin(currState.angle);
		var cang = Math.cos(currState.angle);
		var ang = normalize(normang(currState.angle), 0, TWOPI);
		var bb = globalStore.bbox;
		globalStore.currFeatures = [x, y, depth, ang, sang, cang, globalStore.targetWidth];
		if (!bb.empty()) {
			var xmin = normalize(bb.min.x, viewport.xmin, viewport.xmax);
			var xmax = normalize(bb.max.x, viewport.xmin, viewport.xmax);
			var ymin = normalize(bb.min.y, viewport.ymin, viewport.ymax);
			var ymax = normalize(bb.max.y, viewport.ymin, viewport.ymax);
			globalStore.currFeatures = globalStore.currFeatures.concat([xmin, xmax, ymin, ymax]);
		}
	}

	var branch = function(currState) {
		setCurrFeatures(currState);

		var width = 0.9 * currState.width;
		var length = 2;
		var newang = currState.angle + _gaussian(0, Math.PI/8);	
		// var newang = currState.angle + _uniform(-Math.PI/6, Math.PI/6);
		var newbranch = {
			start: currState.pos,
			angle: newang,
			width: width,
			end: currState.pos.clone().add(polar2rect(length, newang))
		};

		if (heuristicFactors) {
			// Subtract previous heuristic factor
			if (globalStore.branches.length > 0) {
				targetFactor(-1);
			}
		}

		globalStore.branches = globalStore.branches.concat([newbranch]);
		globalStore.bbox = globalStore.bbox.clone();
		globalStore.bbox.expandByPoint(newbranch.start);
		globalStore.bbox.expandByPoint(newbranch.end);

		if (heuristicFactors) {
			// Add new heuristic factor
			targetFactor(1);
		}

		var newState = {
			depth: currState.depth + 1,
			pos: newbranch.end,
			angle: newbranch.angle,
			width: newbranch.width
		};

		// Terminate?
		future(function() {
			if (currState.depth < 10 && _flip(Math.min(0.99, Math.exp(-0.5*(currState.depth-4))))) {
			// if (currState.depth < 10 && _flip(0.5)) {
			// if (_flip(0.5)) {
				future(function() {
					// Continue or fork?
					if (_flip(0.5)) {
					// if (flip(0.5)) {
						branch(newState);
					} else {
						var branchState1 = {
							depth: currState.depth + 1,
							pos: newbranch.end,
							angle: newbranch.angle - Math.abs(_gaussian(0, Math.PI/6)),
							// angle: newbranch.angle - _uniform(0, Math.PI/4),
							width: newbranch.width
						};
						branch(branchState1);
						var branchState2 = {
							depth: currState.depth + 1,
							pos: newbranch.end,
							angle: newbranch.angle + Math.abs(_gaussian(0, Math.PI/6)),
							// angle: newbranch.angle + _uniform(0, Math.PI/4),
							width: newbranch.width
						};
						branch(branchState2);
					}
				});
			}
		});
	};

	var generate = function() {
		setFuturePolicy(futurePolicy);

		globalStore.targetWidth = opts.targetWidth || uniform(1, 15);
		globalStore.targetWidthTightness = opts.targetWidthTightness || globalStore.targetWidth / 10;

		globalStore.branches = [];
		globalStore.bbox = box2();
		globalStore.currFeatures = [];
		var startState = {
			depth: 0,
			pos: vec2(0, 0),
			angle: -Math.PI/2,
			width: 0.75
		};
		future(function() { branch(startState); });
		finishAllFutures();

		if (!heuristicFactors) {
			// Target factor only once, at very end
			targetFactor(1);
		}

		return { branches: globalStore.branches, bbox: globalStore.bbox, targetWidth: globalStore.targetWidth };
	};

	return generate;
}

var progOpts = {
	variational: true,
	heuristicFactors: false,
	targetWidth: 8,
	// targetWidthTightness: 0.1
	futurePolicy: 'deterministic'
};
var generate = makeProgram(progOpts);

var useSavedParams = false;
var saveParams = false;
var paramFile = 'vpf_experiments/lsystem/saved_params/test_params_bbox.txt';

if (progOpts.variational) {
	if (!useSavedParams) {
		Variational(generate, vparams, {
			numParticles: 100,
			maxNumFlights: 1000,
			// convergeEps: 0.1,
			convergeEps: 0.01,
			// adagradInitLearnRate: 0.25,
			// adagradInitLearnRate: 0.1,
			adagradInitLearnRate: 0.05,

			gradientEstimator: 'ELBO',
			// gradientEstimator: 'EUBO',
			// exampleTraces: utils.loadTraces('vpf_experiments/lsystem/data/targetWidth=8.txt'),

			verbosity: {
				flightNum: true,
				scoreDiff: true,
				processRetVals: lsysUtils.processRetVals_width,
				endStatus: true
			}
		});
		if (saveParams) {
			Variational.saveParams(vparams, paramFile);
		}
	} else {
		_.extend(vparams, Variational.loadParams(paramFile));
	}
}

var computeWidthErr = function(bbox, targetWidth) {
	var size = bbox.size();
	return Math.abs(size.x - targetWidth) / targetWidth;
}

var res = {width: 600, height: 600};
var n = 100;
var name = 'test';
var resultsDir = 'vpf_experiments/lsystem/results/bbox/' + name;
if (!fs.existsSync(resultsDir)) {
	fs.mkdirSync(resultsDir);
}
var errs = repeat(n, function(i) {
	var nParticles = 1;
	var ret = sample(ParticleFilter(generate, nParticles));
	var width = ret.bbox.size().x;
	var err = computeWidthErr(ret.bbox, ret.targetWidth);
	console.log(i + ' | width: ' + width + ', target: ' + ret.targetWidth + ', relative error: ' + err);
	if (i % 5 === 0) {
		lsysUtils.renderOut(resultsDir + '/' + (i/5) + '.png', res, viewport, ret.branches);
	}
	return err;
});
console.log('error -  min: ' + listMin(errs) + ', max: ' + listMax(errs) +
	               ', avg: ' + listMean(errs) + ', stddev: ' + listStdev(errs));


// ----------------------------------------------------------------------------


var compareVariationalToPrior = function() {
	var present = { present: require.call(null, 'present') };	// For timing
	var numeric = require.call(null, 'numeric');
	var util = require.call(null, 'util');
	var outfilename = 'width_comparison.csv';
	var outfile = fs.openSync('vpf_experiments/lsystem/experiment_results/bbox/'+outfilename, 'w');
	fs.writeSync(outfile, 'isVariational,numParticles,avgError,avgTime\n');
	var nReps = 100;
	map(function(isVariational) {
		console.log('isVariational = ' + isVariational);
		var genFn = makeProgram(_.extend(_.clone(progOpts), { variational: isVariational }));
		repeat(10, function(np) {
			var nParticles = np + 1;
			console.log('  nParticles = ' + nParticles);
			var errsAndTimes = repeat(nReps, function(i) {
				console.log('    repetition ' + i);
				var t0 = present.present();
				var ret = sample(ParticleFilter(genFn, nParticles));
				var t1 = present.present();
				var time = t1 - t0;
				var err = computeWidthErr(ret.bbox, ret.targetWidth);
				return [err, time];
			});
			var sums = reduce(function(a, b) { return numeric.add(a, b); }, [0, 0], errsAndTimes);
			var avgs = numeric.div(sums, errsAndTimes.length);
			fs.writeSync(outfile, util.format('%s,%d,%d,%d\n',
				isVariational, nParticles, avgs[0], avgs[1]));
		});
	}, [false, true]);
	fs.closeSync(outfile);
}
// compareVariationalToPrior();

var generateTrainingData = function(name) {
	var dataDir = 'vpf_experiments/lsystem/data';
	var fs = require.call(null, 'fs');
	if (!fs.existsSync(dataDir)) {
		fs.mkdirSync(dataDir);
	}
	var filename = dataDir + '/' + name + '.txt';
	var genData = function(counter) {
		var trace = ParticleFilter(generate, 100).trace;
		fs.appendFileSync(filename, JSON.stringify(trace) + '\n');
		console.log('Generated trace ' + counter);
		genData(counter + 1);
	}
	genData(0);
};
// generateTrainingData('targetWidth=8');

undefined;





