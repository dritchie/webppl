<html>
	<head>
		<title>SOSMC L-System Test UI</title>
		<script src='http://code.jquery.com/jquery-1.11.3.min.js'> </script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.min.js'></script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r72/three.min.js'></script>
		<script src='../render.js'></script>
		<script src='../particleHistoryUtils.js'></script>
	</head>
	<body onkeydown='keyEvent(event)'>
		<script>
			var numParticles;
			var particleHistory;
			var viewport;

			var guistate;
			var gui;
			var guicomponents;
			var generationSlider;
			var particleSlider;
			var propDisplays;

			var targetImg;
			var smallTargetImg;

			function renderParticle(canvas, particle, tgtimage) {
				var ctx = canvas.getContext('2d');
				if (tgtimage) {
					// Draw gray-ed out target as background
					ctx.drawImage(tgtimage, 0, 0);
					ctx.globalCompositeOperation = 'lighten';
					ctx.rect(0, 0, canvas.width, canvas.height);
					ctx.fillStyle = 'rgb(128, 128, 128)';
					ctx.fill();
					ctx.globalCompositeOperation = 'source-over';
				}
				// Draw branches
				render(canvas, viewport, particle.branches, 0, particle.branches.length, tgtimage === undefined);
			}

			function showCurrentParticle() {
				var particle = particleHistory[guistate.generationIndex][guistate.particleIndex];

				var canvas = $('#canvas')[0];
				var ctx = canvas.getContext('2d');
				var canvas_small = $('#canvas-small')[0];
				var ctx_small = canvas_small.getContext('2d');

				// Draw
				if (particle.imageData) {
					ctx.putImageData(particle.imageData, 0, 0);
					ctx_small.putImageData(particle.imageDataSmall, 0, 0);
				} else {
					renderParticle(canvas, particle, targetImg);
					// renderParticle(canvas_small, particle, smallTargetImg);
					renderParticle(canvas_small, particle);
					// Save image
					particle.imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
					particle.imageDataSmall = ctx_small.getImageData(0, 0, canvas_small.width, canvas_small.height);
				}

				// Update UI
				console.log('------------------------------');
				for (var propname in propDisplays) {
					propDisplays[propname].setValue(particle[propname]);
					console.log(propname + ': ' + particle[propname]);
				}
			}

			function findBestInGen(genIndex, mustBeFinished) {
				var bestscore = -Infinity;
				var besti = -1;
				var particles = particleHistory[genIndex];
				for (var i = 0; i < particles.length; i++) {
					var p = particles[i];
					if ((!mustBeFinished || !p.active) && p.log_post > bestscore) {
						bestscore = p.log_post;
						besti = i;
					}
				}
				return besti;
			}

			function showBestInGen() {
				var besti = findBestInGen(guistate.generationIndex);
				particleSlider.setValue(besti);
			}

			function findBestOverall(mustBeFinished) {
				var bestscore = -Infinity;
				var besti = -1;
				var bestj = -1;
				for (var i = 0; i < particleHistory.length; i++) {
					var j = findBestInGen(i, mustBeFinished);
					if (j !== -1) {  // mustBeFinished && all particles this gen are active
						var p = particleHistory[i][j];
						if ((!mustBeFinished || !p.active) && p.log_post > bestscore) {
							bestscore = p.log_post;
							besti = i;
							bestj = j;
						}
					}
				}
				return {generationIndex: besti, particleIndex: bestj};
			}

			function showBestOverall() {
				var best = findBestOverall();
				generationSlider.setValue(best.generationIndex);
				particleSlider.setValue(best.particleIndex);
			}

			function showBestOverallFinished() {
				var best = findBestOverall(true);
				generationSlider.setValue(best.generationIndex);
				particleSlider.setValue(best.particleIndex);
			}

			// Arrow keys also allow navigation
			var LEFT_ARROW = 37;
			var UP_ARROW = 38;
			var RIGHT_ARROW = 39;
			var DOWN_ARROW = 40;
			function keyEvent(event) {
				var key = event.keyCode || event.which;
				if (particleHistory) {
					if (key === LEFT_ARROW) {
						var pindex = Math.max(guistate.particleIndex - 1, 0);
						particleSlider.setValue(pindex);
					} else if (key === RIGHT_ARROW) {
						var pindex = Math.min(guistate.particleIndex + 1, numParticles - 1);
						particleSlider.setValue(pindex);
					} else if (key === DOWN_ARROW) {
						var gindex = Math.max(guistate.generationIndex - 1, 0);
						generationSlider.setValue(gindex);
					} else if (key === UP_ARROW) {
						var gindex = Math.min(guistate.generationIndex + 1, particleHistory.length - 1);
						generationSlider.setValue(gindex);
					}
				}
			}

			function loadTargetImages(basename, callback) {
				var targetImgFile = '../targets/source/' + basename + '.png';
				var smallTargetImgFile = '../targets/training/' + basename + '.png';
				targetImg = new Image();
				targetImg.addEventListener('load', function() {
					var bigCanvas = $('#canvas').length ? $('#canvas') : $('<canvas/>', {id: 'canvas'}).appendTo('body');
					bigCanvas.prop({width: targetImg.width, height: targetImg.height});
					smallTargetImg = new Image();
					smallTargetImg.addEventListener('load', function() {
						var smallCanvas = $('#canvas-small').length ? $('#canvas-small') : $('<canvas/>', {id: 'canvas-small'}).appendTo('body');
						smallCanvas.prop({width: smallTargetImg.width, height: smallTargetImg.height});
						callback();
					}, false);
					smallTargetImg.src = smallTargetImgFile;
				}, false);
				targetImg.src = targetImgFile;
			}

			function computePropRange(history, prop) {
				var minval = Infinity;
				var maxval = -Infinity;
				for (var i = 0; i < history.length; i++) {
					var ps = history[i];
					for (var j = 0; j < ps.length; j++) {
						var p = ps[j];
						minval = Math.min(minval, p[prop]);
						maxval = Math.max(maxval, p[prop]);
					}
				}
				return {min: minval, max: maxval};
			}

			function generate() {
				console.log('------------------------------');
				console.log('Generating...');
				$.getJSON('http://localhost:8000', function(data) {
					// Process data
					console.log('   Received data; processing...');
					particleHistory = particleHistoryUtils.decompress(data.history);
					numParticles = particleHistory[0].length;
					viewport = data.viewport;
					loadTargetImages(data.targetName, function() {
						// GUI init
						if (!gui) {
							gui = new dat.GUI();
						} else {
							for (var i = 0; i < guicomponents.length; i++)
								gui.remove(guicomponents[i]);
						}
						guistate = {
							generationIndex: particleHistory.length - 1,
							particleIndex: findBestInGen(particleHistory.length - 1),
							showBestInGen: showBestInGen,
							showBestOverall: showBestOverall,
							showBestOverallFinished: showBestOverallFinished,
						}

						// Sliders for controlling which generation/particle we're looking at.
						generationSlider = gui.add(guistate, 'generationIndex', 0, particleHistory.length-1).step(1).name('Generation');
						generationSlider.onChange(showCurrentParticle);
						particleSlider = gui.add(guistate, 'particleIndex', 0, particleHistory[0].length-1).step(1).name('Particle');
						particleSlider.onChange(showCurrentParticle);
						guicomponents = [generationSlider, particleSlider];

						// Particle properties that we want to display.
						var particleProps = [
							{name: 'num_branches'},
							{name: 'log_prior'},
							{name: 'log_like'},
							{name: 'log_post'},
							{name: 'similarity', range: {min: 0, max: 1}},
							{name: 'active'},
						];
						propDisplays = {};
						var currparticle = particleHistory[guistate.generationIndex][guistate.particleIndex];
						function formatname(name, type) {
							var ret = name.split('_').map(function(word) {
								return word.charAt(0).toUpperCase() + word.slice(1); // capitalize
							}).join(' ');
							if (type === 'boolean') { ret += '?'; }
							return ret;
						}
						for (var i = 0; i < particleProps.length; i++) {
							var prop = particleProps[i];
							var propval = currparticle[prop.name];
							guistate[prop.name] = propval;
							var proptype = typeof(propval);
							var displayName = formatname(prop.name, proptype);
							var displayWidget;
							if (proptype === 'boolean') {
								displayWidget = gui.add(guistate, prop.name).name(displayName);
							} else if (proptype === 'number') {
								var range = prop.range || computePropRange(particleHistory, prop.name);
								displayWidget = gui.add(guistate, prop.name, range.min, range.max).name(displayName);
							} else {
								throw 'Particle property ' + prop.name + ' has unsupported type ' + proptype +
								'; cannot display';
							}
							propDisplays[prop.name] = displayWidget;
							guicomponents.push(displayWidget);
						}

						// Buttons for jumping directly to 'best' particles.
						var bestOverallButton = gui.add(guistate, 'showBestOverall').name('Best');
						var bestOverallFinishedButton = gui.add(guistate, 'showBestOverallFinished').name('Best finished');
						var bestInGenButton = gui.add(guistate, 'showBestInGen').name('Best in gen');
						guicomponents = guicomponents.concat([bestInGenButton, bestOverallButton]);

						// Finish up
						console.log('   DONE.');
						showCurrentParticle();
					});
				});
			}

			// The generate button
			$('<button>Generate</button>').css('font-size', '18pt').click(generate).appendTo('body');

		</script>
	</body>
</html>




