var nnlayers = require('../../src/nn/layers');

var vparam = Variational.param;

var sampleprms = [0, 1e-6];

// Calculate parameters by a linear regression on input features
// (plus non-linear bounding transforms)
function get(params, name, origparams, bounds, features) {
	// If features has different dimensionality, we need separate params,
	//    even if the name is the same.
	name += '(' + features.length + ')';
	// // Add all cross terms to features.
	// var crossFeatures = [];
	// for (var i = 0; i < features.length; i++) {
	// 	for (var j = i; j < features.length; j++) {
	// 		crossFeatures.push(features[i]*features[j]);
	// 	}
	// }
	// features = features.concat(crossFeatures);
	// // Add negations of all features
	// var negFeatures = [];
	// for (var i = 0; i < features.length; i++) {
	// 	negFeatures.push(-features[i]);
	// }
	// features = features.concat(negFeatures);
	var output;
	if (features.length === 0) {
		// Mean field
		output = vparam(params, name, [bounds.length], gaussianERP.sample, sampleprms);
	} else {
		// // Linear network
		// var intercepts = vparam(params, name + '[b]', [bounds.length], gaussianERP.sample, sampleprms);
		// var coeffs = vparam(params, name + '[w]', [bounds.length, features.length], gaussianERP.sample, sampleprms);
		// output = nnlayers.fullyConnected(features, coeffs, intercepts);

		// Neural network
		var nHidden = features.length;
		// var nHidden = 5;
		// var nHidden = 100;
		var nHiddenLayers = 1;
		// var nHiddenLayers = 5;
		var activation = nnlayers.tanh;
		// var activation = nnlayers.sigmoid;
		// var activation = nnlayers.rectifiedLinear;
		var x = features;
		var n = features.length;
		var weights;
		var biases;
		for (var i = 0; i < nHiddenLayers; i++) {
			weights = vparam(params, name + '[w'+i+']', [nHidden, n], gaussianERP.sample, sampleprms);
			biases = vparam(params, name + '[b'+i+']', [nHidden], gaussianERP.sample, sampleprms);
			x = activation(nnlayers.fullyConnected(x, weights, biases));
			n = nHidden;
		}
		weights = vparam(params, name + '[wOut]', [bounds.length, nHidden], gaussianERP.sample, sampleprms);
		biases = vparam(params, name + '[bOut]', [bounds.length], gaussianERP.sample, sampleprms);
		output = nnlayers.fullyConnected(x, weights, biases);
	}
	var result = __AD__.vec2scalars(output);
	for (var i = 0; i < bounds.length; i++) {
		result[i] = bounds[i].fwd(result[i]);
		// result[i] = bounds[i].fwd(result[i] + bounds[i].rvs(origparams[i]));
	}
	return result;
}

module.exports = {
	get: get
}