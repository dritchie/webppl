var THREE = require.call(null, 'three');
var lsysUtils = require.call(null, __ROOT + '/utils.js');


// ----------------------------------------------------------------------------


var vec2 = function(x, y) {
	var v = Object.create(THREE.Vector2.prototype);
	THREE.Vector2.call(v, x, y);
	return v;
}

var box2 = function() {
	var b = Object.create(THREE.Box2.prototype);
	THREE.Box2.call(b);
	return b;
}

var polar2rect = function(r, theta) {
	return vec2(r*Math.cos(theta), r*Math.sin(theta));
}


// ----------------------------------------------------------------------------


var viewport = {xmin: -12, xmax: 12, ymin: -22, ymax: 2};

var targetDB = lsysUtils.newTargetImageDatabase('targets/training');

// var futurePolicy = 'immediate';
// var futurePolicy = 'lifo';
// var futurePolicy = 'fifo';
// var futurePolicy = 'uniformFromAll';
var futurePolicy = 'uniformFromDeepest';
// var futurePolicy = 'depthWeighted';
setFuturePolicy(futurePolicy);


// ----------------------------------------------------------------------------


// Compute normalized similarity for a set of branches
var computeSim = function(branches, inInference) {
	var target = globalStore.target;
	// If not in inference, just render everything
	if (!inInference) {
		lsysUtils.render(target.canvas, viewport, branches);
	// Otherwise, do an incremental render of the last branch
	} else {
		globalStore.genImg.copyToCanvas(target.canvas);
		lsysUtils.render(target.canvas, viewport, branches, true, false);
	}
	globalStore.genImg = lsysUtils.newImageData2D().loadFromCanvas(target.canvas);
	return lsysUtils.normalizedSimilarity(globalStore.genImg, globalStore.target);
};

// Basically Gaussian log-likelihood, without the constant factor
var makescore = function(val, target, tightness) {
	var diff = val - target;
	return - (diff * diff) / (tightness * tightness);
}

var simTightness = 0.02;
var boundsTightness = 0.001;
var availableFuturesWeight = 25;
var targetFactor = function() {
	// Similarity factor
	var sim = computeSim(globalStore.branches, true);
	globalStore.sim = sim;
	var simf = makescore(sim, 1, simTightness);
	// Bounds factors
	var bbox = globalStore.bbox;
	var extraX = (Math.max(viewport.xmin - bbox.min.x, 0) + Math.max(bbox.max.x - viewport.xmax, 0)) / (viewport.xmax - viewport.xmin);
	var extraY = (Math.max(viewport.ymin - bbox.min.y, 0) + Math.max(bbox.max.y - viewport.ymax, 0)) / (viewport.ymax - viewport.ymin);
	var boundsfx = makescore(extraX, 0, boundsTightness);
	var boundsfy = makescore(extraY, 0, boundsTightness);
	var f = simf + boundsfx + boundsfy;
	// ////
	// // More available futures factor
	// var fprime = simf + boundsfx + boundsfy;
	// var f = fprime + availableFuturesWeight*availableFuturesScore();
	// ////
	if (globalStore.prevFactor) {
		factor(f - globalStore.prevFactor);
	} else {
		factor(f);
	}
	globalStore.prevFactor = f;
};


// ----------------------------------------------------------------------------

var setCurrFeatures = function(currState) {
	globalStore.currFeatures = [
		currState.pos.x,
		currState.pos.y,
		currState.depth,
		currState.angle
	];
};

var initialWidth = 0.75;
var widthDecay = 0.975;
var minWidthPercent = 0.2;

var branch = function(currState) {
	setCurrFeatures(currState);

	// Generate new branch
	var width = widthDecay * currState.width;
	var length = 2;
	var newang = currState.angle + gaussian(0, Math.PI/8);	
	var newbranch = {
		start: currState.pos,
		angle: newang,
		width: width,
		end: currState.pos.clone().add(polar2rect(length, newang))
	};

	// Update model state
	globalStore.branches = { branch: newbranch, next: globalStore.branches };
	globalStore.numBranches = globalStore.numBranches + 1;
	globalStore.bbox = globalStore.bbox.clone();
	globalStore.bbox.expandByPoint(newbranch.start);
	globalStore.bbox.expandByPoint(newbranch.end);

	// Add new heuristic factor
	targetFactor();

	var newState = {
		depth: currState.depth + 1,
		pos: newbranch.end,
		angle: newbranch.angle,
		width: newbranch.width
	};

	// Terminate?
	future(function() {
		var terminateProb = 0.5;
		if (flip(terminateProb)) {
			globalStore.terminated = true;
		} else {
			// Generate no further branches w/ prob 1/3
			// Generate one further branch w/ prob 1/3
			// Generate two further branches w/ prob 1/3
			future(function() {
				if (!globalStore.terminated && newState.width/initialWidth > minWidthPercent && flip(0.66)) {
					branch(newState);
					future(function() {
						if (!globalStore.terminated && newState.width/initialWidth > minWidthPercent && flip(0.5)) {
							branch(newState);
						}
						// else factor(0);
					});
				}
				// else factor(0);
			});
		}
	});
};

var generate = function() {
	// If target is not fixed, then marginalize over targets
	if (globalStore.target === undefined) {
		globalStore.target = targetDB.getTargetByIndex(randomInteger(targetDB.numTargets()));
	}
	var w = globalStore.target.image.width;
	var h = globalStore.target.image.height;
	globalStore.genImg = lsysUtils.newImageData2D().fillWhite(w, h);
	globalStore.branches = undefined;
	globalStore.numBranches = 0;
	globalStore.bbox = box2();
	globalStore.currFeatures = [];
	var startState = {
		depth: 0,
		pos: vec2(0, 0),
		angle: gaussian(-Math.PI/2, Math.PI/6),
		width: initialWidth
	};
	future(function() { branch(startState); });
	finishAllFutures();
	return globalStore.branches;
};

// Return stuff that external tasks will need
var returner = function() {
	return {
		generate: generate,
		targetDB: targetDB,
		viewport: viewport,
		globalStore: globalStore,
		environment: env
	}
};
returner();





