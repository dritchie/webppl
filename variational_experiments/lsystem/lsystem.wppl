var utils = require.call(null, __ROOT + '/../utils.js');
var lsysUtils = require.call(null, __ROOT + '/utils.js');
var render = require.call(null, __ROOT + '/render.js');
var THREE = require.call(null, 'three');
var Tensor = require.call(null, 'adnn/tensor');
var ad = require.call(null, 'adnn/ad');
var nn = require.call(null, 'adnn/nn');


// ----------------------------------------------------------------------------
// Utilities


var polar2rect = function(r, theta) {
	return utils.new(THREE.Vector2, r*Math.cos(theta), r*Math.sin(theta));
};

var fuzz = [0, 1e-8];
var normalize = function(x, lo, hi) {
	// Fuzz prevents values from normalizing to exactly zero (causing zero
	//    derivatives)
	return (2 * (x - lo) / (hi - lo)) - 1 + gaussianERP.sample(fuzz);
};

var TWOPI = 2*Math.PI;
var normang = function(theta) {
	if (theta >= 0) {
		return theta - (TWOPI*Math.floor(theta / TWOPI));
	} else {
		return theta - (TWOPI*Math.ceil(theta / TWOPI)) + TWOPI;
	}
};


// ----------------------------------------------------------------------------
// Other globals


var viewport = {xmin: -12, xmax: 12, ymin: -22, ymax: 2};

var targetDB = utils.new(lsysUtils.TargetImageDatabase, 'targets/training');

// var futurePolicy = 'immediate';
// var futurePolicy = 'lifo';
// var futurePolicy = 'fifo';
// var futurePolicy = 'uniformFromAll';
var futurePolicy = 'uniformFromDeepest';
// var futurePolicy = 'depthWeighted';
setFuturePolicy(futurePolicy);


// ----------------------------------------------------------------------------
// Factor encouraging similarity to target image


// Compute normalized similarity for a set of branches
var computeSim = function(branches, inInference) {
	var target = globalStore.target;
	// If not in inference, just render everything
	if (!inInference) {
		render.render(target.canvas, viewport, branches);
	// Otherwise, do an incremental render of the last branch
	} else {
		globalStore.genImg.copyToCanvas(target.canvas);
		render.render(target.canvas, viewport, branches, true, false);
	}
	globalStore.genImg = utils.new(lsysUtils.ImageData2D).loadFromCanvas(target.canvas);
	return lsysUtils.normalizedSimilarity(globalStore.genImg, globalStore.target);
};

// Basically Gaussian log-likelihood, without the constant factor
var makescore = function(val, target, tightness) {
	var diff = val - target;
	return - (diff * diff) / (tightness * tightness);
}

var simTightness = 0.02;
var boundsTightness = 0.001;
var availableFuturesWeight = 25;
var targetFactor = function() {
	// Similarity factor
	var sim = computeSim(globalStore.branches, true);
	globalStore.sim = sim;
	var simf = makescore(sim, 1, simTightness);
	// Bounds factors
	var bbox = globalStore.bbox;
	var extraX = (Math.max(viewport.xmin - bbox.min.x, 0) + Math.max(bbox.max.x - viewport.xmax, 0)) / (viewport.xmax - viewport.xmin);
	var extraY = (Math.max(viewport.ymin - bbox.min.y, 0) + Math.max(bbox.max.y - viewport.ymax, 0)) / (viewport.ymax - viewport.ymin);
	var boundsfx = makescore(extraX, 0, boundsTightness);
	var boundsfy = makescore(extraY, 0, boundsTightness);
	var f = simf + boundsfx + boundsfy;
	// ////
	// // More available futures factor
	// var fprime = simf + boundsfx + boundsfy;
	// var f = fprime + availableFuturesWeight*availableFuturesScore();
	// ////
	if (globalStore.prevFactor) {
		factor(f - globalStore.prevFactor);
	} else {
		factor(f);
	}
	globalStore.prevFactor = f;
};


// ----------------------------------------------------------------------------
// Neural network guide stuff


// Whether to use RNN for latent global state, or CNN on image-thus-far.
var useRecurrentState = false;

// Register variational params and set training to true
var netwrapper = function(fn) {
	return function() {
		var net = apply(fn, arguments);
		registerVariationalParams(net.parameters);
		net.setTraining(true);
		return net;
	};
};

var nImgFilters = 1;
var filterSize = 5;
var imgSize = 50;
var imgSizeReduced1 = Math.floor(imgSize/2);
var imgSizeReduced2 = Math.floor(imgSizeReduced1/2);
var imgSizeReduced3 = Math.floor(imgSizeReduced2/2);
var nTargetFeatures = imgSizeReduced3*imgSizeReduced3*nImgFilters;

var nLocalFeatures = 4;
var nRecurrentStateFeatures = 10;

var nStateFeatures = useRecurrentState ? nRecurrentStateFeatures : nTargetFeatures;

// Convolutional network that parses the target image (or generated image).
var makeCNN = netwrapper(function() {
	return nn.sequence([
		nn.convolution({filterSize: filterSize, outDepth: nImgFilters}),
		nn.maxpool({filterSize: 2}),
		nn.convolution({filterSize: filterSize, outDepth: nImgFilters}),
		nn.maxpool({filterSize: 2}),
		nn.convolution({filterSize: filterSize, outDepth: nImgFilters}),
		nn.maxpool({filterSize: 2})
	]);
});

// Recurrent network that tracks latent global state.
var makeInitState = netwrapper(function() {
	return nn.constantparams([nStateFeatures]);
});
var makeStateRNN = netwrapper(function() {
	var localInput = nn.ast.input();
	var latentInput = nn.ast.input();
	var concatNode = nn.concat.compose(localInput, latentInput);
	var nIn = nLocalFeatures + nStateFeatures;
	var mlpNode = nn.mlp(nIn, [
		{nOut: nIn, activation: nn.relu},
		{nOut: nStateFeatures}
	]).compose(concatNode);
	return nn.ast.compile([localInput, latentInput], [mlpNode]);
});

// Per-callsite MLPs that combine target state and latent state with
//    current local features.
var makeParamPredictMLP = netwrapper(function(nOut) {
	var localInput = nn.ast.input();
	var latentInput = nn.ast.input();
	var targetInput = nn.ast.input();
	var concatNode = nn.concat.compose(localInput, latentInput, targetInput);
	var nIn = nLocalFeatures + nStateFeatures + nTargetFeatures;
	var mlpNode = nn.mlp(nIn, [
		{nOut: Math.floor(nIn/2), activation: nn.relu},
		{nOut: nOut}
	]).compose(concatNode);
	return nn.ast.compile([localInput, latentInput, targetInput], [mlpNode]);
});

var neuralNetwork = cache(function() {
	var args = arguments;
	var id = args[0];
	if (id === 'targetCNN' || id === 'genCNN') {
		return makeCNN();
	} else if (id === 'stateInit') {
		return makeInitState();
	} else if (id === 'stateRNN') {
		return makeStateRNN();
	} else {
		var nOut = args[1];
		return makeParamPredictMLP(nOut);
	}
});


// ----------------------------------------------------------------------------
// The program itself


var makeProgram = function(neurallyGuided) {

	// Set up ERPs (either normal or neurally-guided)
	var makeSampler = function(erpName, bounds) {
		var erp = global[erpName];
		var verp = Variational[erpName];
		var n = bounds.length;
		return !neurallyGuided ? 
		function() {
			var params = Array.prototype.slice.call(arguments, 0, n);
			return sample(erp, params);
		}
		:
		function() {
			var params = Array.prototype.slice.call(arguments, 0, n);
			var localState = arguments[n];
			var name = arguments[n+1];	// TODO: replace with callsite id
			var vparams = neuralNetwork(name, n).eval(
				localState.features, globalStore.stateFeatures, globalStore.targetFeatures
			);
			var scalarizedParams = ad.tensorToScalars(vparams);
			var finalParams = mapIndexed(function(i, p) {
				return bounds[i] ? bounds[i].call(null, p) : p;
			}, scalarizedParams);
			verp.importanceERP.setParams(finalParams);
			return sample(verp, params);
		};
	};
	var _gaussian = makeSampler('gaussianERP', [undefined, ad.scalar.exp]);
	var _flip = makeSampler('bernoulliERP', [ad.scalar.sigmoid]);


	var initialWidth = 0.75;
	var widthDecay = 0.975;
	var minWidthPercent = 0.2;
	var minWidth = minWidthPercent*initialWidth;

	var state = function(obj) {
		var features = utils.new(Tensor, [4]).fromFlatArray([
			normalize(obj.pos.x, viewport.xmin, viewport.xmax),
			normalize(obj.pos.y, viewport.ymin, viewport.ymax),
			normalize(obj.width, minWidth, initialWidth),
			normalize(normang(obj.angle), 0, TWOPI)
		]);
		return {
			depth: obj.depth,
			pos: obj.pos,
			angle: obj.angle,
			width: obj.width,
			features: features
		};
	};

	var branch = function(currState) {

		// Generate new branch
		var width = widthDecay * currState.width;
		var length = 2;
		// var newang = currState.angle + gaussian(0, Math.PI/8);
		var newang = currState.angle + _gaussian(0, Math.PI/8, currState, 'angle');
		var newbranch = {
			start: currState.pos,
			angle: newang,
			width: width,
			end: currState.pos.clone().add(polar2rect(length, newang))
		};

		// Update model state
		globalStore.branches = { branch: newbranch, next: globalStore.branches };
		globalStore.numBranches = globalStore.numBranches + 1;
		globalStore.bbox = globalStore.bbox.clone();
		globalStore.bbox.expandByPoint(newbranch.start);
		globalStore.bbox.expandByPoint(newbranch.end);

		// Add new heuristic factor
		if (!globalStore.noFactors) targetFactor();

		var newState = state({
			depth: currState.depth + 1,
			pos: newbranch.end,
			angle: newbranch.angle,
			width: newbranch.width
		});

		if (neurallyGuided)  {
			if (useRecurrentState) {
				globalStore.stateFeatures = neuralNetwork('stateRNN').eval(
					newState.features, globalStore.stateFeatures);
			} else {
				globalStore.stateFeatures = neuralNetwork('genCNN').eval(globalStore.genImg.toTensor());
			}
		}

		// Terminate?
		future(function() {
			var terminateProb = 0.5;
			// if (flip(terminateProb)) {
			if (flip(terminateProb, newState, 'terminate')) {
				globalStore.terminated = true;
			} else {
				// Generate no further branches w/ prob 1/3
				// Generate one further branch w/ prob 1/3
				// Generate two further branches w/ prob 1/3
				future(function() {
					// if (!globalStore.terminated && newState.width > minWidth && flip(0.66)) {
						if (!globalStore.terminated && newState.width > minWidth && flip(0.66, newState, 'branch1')) {
						branch(newState);
						future(function() {
							// if (!globalStore.terminated && newState.width > minWidth && flip(0.5)) {
								if (!globalStore.terminated && newState.width > minWidth && flip(0.5, newState, 'branch2')) {
								branch(newState);
							}
							// else factor(0);
						});
					}
					// else factor(0);
				});
			}
		});
	};

	var generate = function() {
		// If target is not fixed, then marginalize over targets
		if (globalStore.target === undefined) {
			globalStore.target = targetDB.getTargetByIndex(randomInteger(targetDB.numTargets()));
		}
		var w = globalStore.target.image.width;
		var h = globalStore.target.image.height;
		globalStore.genImg = utils.new(lsysUtils.ImageData2D).fillWhite(w, h);
		if (neurallyGuided) {
			globalStore.targetFeatures = neuralNetwork('targetCNN').eval(globalStore.target.tensor);
			if (useRecurrentState) {
				globalStore.stateFeatures = neuralNetwork('initState').eval();
			} else {
				globalStore.stateFeatures = neuralNetwork('genCNN').eval(globalStore.genImg.toTensor());
			}
		}
		globalStore.branches = undefined;
		globalStore.numBranches = 0;
		globalStore.bbox = utils.new(THREE.Box2);
		globalStore.currFeatures = [];
		var startState = state({
			depth: 0,
			pos: utils.new(THREE.Vector2, 0, 0),
			angle: gaussian(-Math.PI/2, Math.PI/6),
			width: initialWidth
		});
		future(function() { branch(startState); });
		finishAllFutures();
		return globalStore.branches;
	};

	return generate;
}


// ----------------------------------------------------------------------------
// Return stuff that external tasks will need


var rets = {
	generate: makeProgram(false),
	generateGuided: makeProgram(true),
	targetDB: targetDB,
	viewport: viewport,
	globalStore: globalStore,
	neuralNets: neuralNetwork.cache,
	environment: env
};
rets;





