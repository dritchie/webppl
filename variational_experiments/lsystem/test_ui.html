<html>
	<head>
		<title>SOSMC L-System Test UI</title>
		<script src='http://code.jquery.com/jquery-1.11.3.min.js'> </script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.min.js'></script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r72/three.min.js'></script>
		<script src='render.js'></script>
		<script src='particleHistoryUtils.js'></script>
		<script id="vines-vs" type="x-shader/x-vertex"> 
			//
			// Description : Array and textureless GLSL 2D simplex noise function.
			//      Author : Ian McEwan, Ashima Arts.
			//  Maintainer : ijm
			//     Lastmod : 20110822 (ijm)
			//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
			//               Distributed under the MIT License. See LICENSE file.
			//               https://github.com/ashima/webgl-noise
			// 

			vec3 mod289(vec3 x) {
			  return x - floor(x * (1.0 / 289.0)) * 289.0;
			}

			vec2 mod289(vec2 x) {
			  return x - floor(x * (1.0 / 289.0)) * 289.0;
			}

			vec3 permute(vec3 x) {
			  return mod289(((x*34.0)+1.0)*x);
			}

			float snoise(vec2 v)
			  {
			  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
			                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
			                     -0.577350269189626,  // -1.0 + 2.0 * C.x
			                      0.024390243902439); // 1.0 / 41.0
			// First corner
			  vec2 i  = floor(v + dot(v, C.yy) );
			  vec2 x0 = v -   i + dot(i, C.xx);

			// Other corners
			  vec2 i1;
			  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
			  vec4 x12 = x0.xyxy + C.xxzz;
			  x12.xy -= i1;

			// Permutations
			  i = mod289(i); // Avoid truncation effects in permutation
			  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
					+ i.x + vec3(0.0, i1.x, 1.0 ));

			  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
			  m = m*m ;
			  m = m*m ;

			// Gradients: 41 points uniformly over a line, mapped onto a diamond.
			// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

			  vec3 x = 2.0 * fract(p * C.www) - 1.0;
			  vec3 h = abs(x) - 0.5;
			  vec3 ox = floor(x + 0.5);
			  vec3 a0 = x - ox;

			// Normalise gradients implicitly by scaling m
			// Approximation of: m *= inversesqrt( a0*a0 + h*h );
			  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

			// Compute final noise value at P
			  vec3 g;
			  g.x  = a0.x  * x0.x  + h.x  * x0.y;
			  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
			  return 130.0 * dot(m, g);
			}

			// ----------------------------------------------------------------

			uniform mat3 viewMat;

			attribute vec2 inPos;
			attribute vec2 inUV;
			attribute vec2 inNorm;
			varying vec2 outUV;

			float freq = 2.;
			float amp = 0.01;
			// float amp = 0.0;

			void main(void) {
				outUV = inUV;
				vec2 ndcpos = (viewMat * vec3(inPos, 1.)).xy;
				gl_Position = vec4(ndcpos + amp*snoise(freq*inUV)*inNorm, 0., 1.);
			}

		</script>
		<script id="vines-fs" type="x-shader/x-fragment">
			precision mediump float;

			// Cellular noise ("Worley noise") in 2D in GLSL.
			// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
			// This code is released under the conditions of the MIT license.
			// See LICENSE file for details.

			// Permutation polynomial: (34x^2 + x) mod 289
			vec3 permute(vec3 x) {
			  return mod((34.0 * x + 1.0) * x, 289.0);
			}

			// Cellular noise, returning F1 and F2 in a vec2.
			// Standard 3x3 search window for good F1 and F2 values
			vec2 cellular(vec2 P) {
			#define K 0.142857142857 // 1/7
			#define Ko 0.428571428571 // 3/7
			#define jitter 1.0 // Less gives more regular pattern
				vec2 Pi = mod(floor(P), 289.0);
			 	vec2 Pf = fract(P);
				vec3 oi = vec3(-1.0, 0.0, 1.0);
				vec3 of = vec3(-0.5, 0.5, 1.5);
				vec3 px = permute(Pi.x + oi);
				vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13
				vec3 ox = fract(p*K) - Ko;
				vec3 oy = mod(floor(p*K),7.0)*K - Ko;
				vec3 dx = Pf.x + 0.5 + jitter*ox;
				vec3 dy = Pf.y - of + jitter*oy;
				vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared
				p = permute(px.y + Pi.y + oi); // p21, p22, p23
				ox = fract(p*K) - Ko;
				oy = mod(floor(p*K),7.0)*K - Ko;
				dx = Pf.x - 0.5 + jitter*ox;
				dy = Pf.y - of + jitter*oy;
				vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared
				p = permute(px.z + Pi.y + oi); // p31, p32, p33
				ox = fract(p*K) - Ko;
				oy = mod(floor(p*K),7.0)*K - Ko;
				dx = Pf.x - 1.5 + jitter*ox;
				dy = Pf.y - of + jitter*oy;
				vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared
				// Sort out the two smallest distances (F1, F2)
				vec3 d1a = min(d1, d2);
				d2 = max(d1, d2); // Swap to keep candidates for F2
				d2 = min(d2, d3); // neither F1 nor F2 are now in d3
				d1 = min(d1a, d2); // F1 is now in d1
				d2 = max(d1a, d2); // Swap to keep candidates for F2
				d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller
				d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x
				d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz
				d1.y = min(d1.y, d1.z); // nor in  d1.z
				d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.
				return sqrt(d1.xy);
			}

			// ----------------------------------------------------------------

			varying vec2 outUV;

			float ufreq = 4.;
			float vfreq = 1.;
			float amt = .6; 

			vec3 green0 = vec3(10./255., 70./255., 0./255.);
			vec3 green1 = vec3(100./255., 175./255., 12./255.);

			void main(void) {
				vec3 green = mix(0.5*green0, 2.*green1, outUV[0]);;
				vec2 F = cellular(vec2(ufreq*outUV.x, vfreq*outUV.y));
				float f = F.y - F.x;
				float s = mix(1., f, amt);
				gl_FragColor = vec4(s*green, 1.);
			}

		</script>
	</head>
	<body onkeydown='keyEvent(event)'>
		<script>
			var numParticles;
			var particleHistory;
			var viewport;

			var guistate;
			var gui;
			var guicomponents;
			var generationSlider;
			var particleSlider;
			var propDisplays;

			var targetImg;
			var smallTargetImg;

			// ----------------------------------------------------------------

			function getShader ( gl, id ){
			   var shaderScript = document.getElementById ( id );
			   var str = "";
			   var k = shaderScript.firstChild;
			   while ( k ){
			     if ( k.nodeType == 3 ) str += k.textContent;
			     k = k.nextSibling;
			   }
			   var shader;
			   if ( shaderScript.type == "x-shader/x-fragment" )
			           shader = gl.createShader ( gl.FRAGMENT_SHADER );
			   else if ( shaderScript.type == "x-shader/x-vertex" )
			           shader = gl.createShader(gl.VERTEX_SHADER);
			   else return null;
			   gl.shaderSource(shader, str);
			   gl.compileShader(shader);
			   if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)
			      alert(id + "\n" + gl.getShaderInfoLog(shader));
			   return shader;
			}

			function makeBezierUniform(n) {
				function bezierEval(p0, p1, p2, p3, t) {
					var p01 = p0.clone().lerp(p1, t);
					var p12 = p1.clone().lerp(p2, t);
					var p23 = p2.clone().lerp(p3, t);
					var p012 = p01.lerp(p12, t);
					var p123 = p12.lerp(p23, t);
					var p = p012.clone().lerp(p123, t);
					var tan = p123.sub(p012).normalize();
					return {
						point: p,
						tangent: tan
					}
				}
				return function bezierUniform(cps) {
					var p0 = cps[0];
					var p1 = cps[1];
					var p2 = cps[2];
					var p3 = cps[3];
					var points = [];
					for (var i = 0; i < n; i++) {
						var t = i / (n-1);
						points.push(bezierEval(p0, p1, p2, p3, t));
					}
					return points;
				}
			}

			// Return bezier control points for a given set of interpolation
			//    points. 
			// Assumes that points are all equally spaced 1 unit apart in knot space
			function controlPoints(p0, p1, prev, next) {
				// Compute tangents
				var m0, m1;
				if (prev === undefined) {
					m0 = p1.clone().sub(p0);
				} else {
					m0 = p1.clone().sub(p0).divideScalar(2).add(
						p0.clone().sub(prev).divideScalar(2)
					);
				}
				if (next === undefined) {
					m1 = p1.clone().sub(p0);
				} else {
					m1 = p1.clone().sub(p0).divideScalar(2).add(
						next.clone().sub(p1).divideScalar(2)
					);
				}
				// Turn tangents into middle two bezier control points
				var p01 = p0.clone().add(m0.divideScalar(3));
				var p11 = p1.clone().sub(m1.divideScalar(3));
				return [p0, p01, p11, p1];
			}

			function vine(cps, curveFn, width0, width1, v0, v1) {
				var points = curveFn(cps);
				var n = points.length;

				var accumlengths = [0];
				for (var i = 1; i < n; i++) {
					var p = points[i].point;
					var p0 = points[i-1].point;
					var l = p.clone().sub(p0).length();
					var l0 = accumlengths[i-1];
					accumlengths.push(l+l0);
				}
				var totallength = accumlengths[n-1];
				var ts = [];
				var uvs = [];
				for (var i = 0; i < n; i++) {
					var t = accumlengths[i] / totallength;
					ts.push(t);
					var v = (1-t)*v0 + t*v1;
					uvs.push(new THREE.Vector2(0, v));
					uvs.push(new THREE.Vector2(1, v));
				}

				var vertices = [];
				var normals = [];
				for (var i = 0; i < n; i++) {
					var b = points[i];
					var center = b.point;
					var tangent = b.tangent;
					var normal = new THREE.Vector2(-tangent.y, tangent.x);
					var t = ts[i];
					var width = (1-t)*width0 + t*width1;
					var w2 = 0.5*width;
					normal.multiplyScalar(w2);
					var p0 = center.clone().sub(normal);
					var p1 = center.clone().add(normal);
					vertices.push(p0);
					vertices.push(p1);
					normals.push(normal.clone().negate());
					normals.push(normal);
				}

				var indices = [];
				var idx = 0;
				for (var i = 0; i < n-1; i++) {
					indices.push(idx); indices.push(idx+1); indices.push(idx+2);
					indices.push(idx+1); indices.push(idx+3); indices.push(idx+2);
					idx += 2;
				}

				return {
					vertices: vertices,
					uvs: uvs,
					normals: normals,
					indices: indices
				};
			}

			function meshToBuffers(mesh) {

				var vertices = [];
				var n = mesh.vertices.length;
				for (var i = 0; i < n; i++) {
					var v = mesh.vertices[i];
					vertices.push(v.x); vertices.push(v.y);
				}

				var uvs = [];
				n = mesh.uvs.length;
				for (var i = 0; i < n; i++) {
					var uv = mesh.uvs[i];
					uvs.push(uv.x); uvs.push(uv.y);
				}

				var normals = [];
				n = mesh.normals.length;
				for (var i = 0; i < n; i++) {
					var nrm = mesh.normals[i];
					normals.push(nrm.x); normals.push(nrm.y);
				}

				return {
					vertices: new Float32Array(vertices),
					uvs: new Float32Array(uvs),
					normals: new Float32Array(normals),
					indices: new Uint16Array(mesh.indices)
				};
			}

			function viewportMatrix(v) {
				// Column-major nonsense
				return [
					2 /(v.xmax - v.xmin), 0, 0,
					0, 2 / (v.ymax - v.ymin), 0,
					-(v.xmin + v.xmax) / (v.xmax - v.xmin), -(v.ymin + v.ymax) / (v.ymax - v.ymin), 1
				];
			}

			function drawBuf(gl, locs, buf) {
				gl.enableVertexAttribArray( locs.vertices );
				var posBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, buf.vertices, gl.STATIC_DRAW);
				gl.vertexAttribPointer(locs.vertices, 2, gl.FLOAT, false, 0, 0);

				gl.enableVertexAttribArray( locs.uvs );
				var uvBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, buf.uvs, gl.STATIC_DRAW);
				gl.vertexAttribPointer(locs.uvs, 2, gl.FLOAT, false, 0, 0);

				gl.enableVertexAttribArray( locs.normals );
				var normBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, buf.normals, gl.STATIC_DRAW);
				gl.vertexAttribPointer(locs.normals, 2, gl.FLOAT, false, 0, 0);

				var indexBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, buf.indices, gl.STATIC_DRAW);

				gl.drawElements(gl.TRIANGLES, buf.indices.length, gl.UNSIGNED_SHORT, 0);
			}

			function drawVineSeg(gl, locs, bezFn, cps, width0, width1, v0, v1) {
				var mesh = vine(cps, bezFn, width0, width1, v0, v1);
				var buf = meshToBuffers(mesh);
				drawBuf(gl, locs, buf);
			}

			function drawVineTree(gl, locs, bezFn, tree) {
				function drawVineTreeRec(tree, v, prevs) {
					// Handle this point
					if (prevs.length > 0) {
						var p0 = prevs[prevs.length - 1].point;
						var p1 = tree.point;
						var prev = prevs.length === 2 ? prevs[0].point : undefined;
						var next = undefined;
						if (tree.children.length === 1) {
							next = tree.children[0].point;
						} else if (tree.children.length === 2) {
							// next = tree.children[0].point.clone().add(
							// 	tree.children[1].point
							// ).multiplyScalar(0.5);
							// next = tree.children[0].point;
							next = tree.children[1].point;
						}
						var cps = controlPoints(p0, p1, prev, next);
						var w0 = prevs[prevs.length - 1].width;
						var w1 = tree.width;
						drawVineSeg(gl, locs, bezFn, cps, w0, w1, v, v + 1);
					}

					// Recurse
					prevs.push(tree);
					if (prevs.length > 2) {
						prevs.shift();
					}
					for (var i = 0; i < tree.children.length; i++) {
						drawVineTreeRec(tree.children[i], v + 1, prevs.slice());
					}
				}

				drawVineTreeRec(tree, 0, []);
			}

			// Convert branch linked list (w/ parent pointers) to a top-down point tree
			//    (for WebGL vine rendering)
			function branchListToPointTree(branches) {
				// Kept in correspondence to map one to the other
				var linkedListNodes = [];
				var treeNodes = [];

				// Sweep through once to create the nodes, but not the child pointers
				for (var br = branches; br; br = br.next) {
					// Store the tree root specially (since it doesn't map to anything
					//    in the linked list)
					if (br.parent === undefined) {
						treeNodes.root = {
							// Needed b/c JSON loses prototype information
							point: new THREE.Vector2().copy(br.branch.start),
							width: br.branch.width,
							children: []
						};
					}
					treeNodes.push({
						point: new THREE.Vector2().copy(br.branch.end),
						width: br.branch.width,
						children: []
					});
					linkedListNodes.push(br);
				}

				// Sweep through a second time to create child pointers
				for (var br = branches; br; br = br.next) {
					var idx = linkedListNodes.indexOf(br);
					var treeNode = treeNodes[idx];
					var parentBr = br.parent;
					var parentIdx = parentBr === undefined ? 'root' : linkedListNodes.indexOf(parentBr);
					var parentNode = treeNodes[parentIdx];
					parentNode.children.push(treeNode);
				}


				return treeNodes.root;
			}

			var gl, locs, bezFn;
			function renderParticleAsVines(canvas, particle) {
				// Setup WebGL context
				if (gl === undefined) {
					var glcanvas = $('#canvas-gl')[0];
					gl = glcanvas.getContext('webgl');

					var prog  = gl.createProgram();
					var vertShader = getShader( gl, "vines-vs" );
					var fragShader = getShader( gl, "vines-fs" ); 
					gl.attachShader(prog, vertShader);
					gl.attachShader(prog, fragShader);
					gl.linkProgram(prog);
					gl.useProgram(prog);

					locs = {
						vertices: gl.getAttribLocation(prog, "inPos"),
						uvs: gl.getAttribLocation(prog, "inUV"),
						normals: gl.getAttribLocation(prog, "inNorm")
					}

					var viewportMat = viewportMatrix(viewport);
					gl.uniformMatrix3fv(gl.getUniformLocation(prog, 'viewMat'), false, viewportMat);

					gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

					bezFn = makeBezierUniform(20);
				}

				// Render
				gl.clearColor(0, 0, 0, 0);
				gl.clear(gl.COLOR_BUFFER_BIT);
				var tree = branchListToPointTree(particle.branches);
				drawVineTree(gl, locs, bezFn, tree);
				gl.flush();

				// Read back pixels
				var arr = new Uint8Array(canvas.width*canvas.height*4);
				gl.readPixels(0, 0, canvas.width, canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, arr);
				var ctx = canvas.getContext('2d');
				// Draw image to canvas
				// (Doing this pixel-by-pixel on CPU, b/c there doesn't appear to be 
				//    a generally-supported better alternative as of yet)
				var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
				var data = imgData.data;
				var n = data.length / 4;
				for (var i = 0; i < n; i++) {
					var ri = 4*i;
					var gi = 4*i+1;
					var bi = 4*i+2;

					var alpha = arr[4*i+3]/255;
					data[ri] = Math.floor((1-alpha)*data[ri] + alpha*arr[ri]);
					data[gi] = Math.floor((1-alpha)*data[gi] + alpha*arr[gi]);
					data[bi] = Math.floor((1-alpha)*data[bi] + alpha*arr[bi]);
				}
				ctx.putImageData(imgData, 0, 0);
			}

			// ----------------------------------------------------------------

			function renderParticleAsLineSegs(canvas, particle) {
				render.render(canvas, viewport, particle.branches, false, false);
			}

			function renderParticle(canvas, particle, tgtimage) {
				var ctx = canvas.getContext('2d');
				if (tgtimage) {
					// Draw gray-ed out target as background
					ctx.drawImage(tgtimage, 0, 0);
					ctx.globalCompositeOperation = 'lighten';
					ctx.rect(0, 0, canvas.width, canvas.height);
					ctx.fillStyle = 'rgb(128, 128, 128)';
					ctx.fill();
					ctx.globalCompositeOperation = 'source-over';
				}
				// Draw branches
				// renderParticleAsLineSegs(canvas, particle);
				renderParticleAsVines(canvas, particle);
			}

			function showCurrentParticle() {
				var particle = particleHistory[guistate.generationIndex][guistate.particleIndex];

				var canvas = $('#canvas')[0];
				var ctx = canvas.getContext('2d');
				var canvas_small = $('#canvas-small')[0];
				var ctx_small = canvas_small.getContext('2d');

				// Draw
				if (particle.imageData) {
					ctx.putImageData(particle.imageData, 0, 0);
					ctx_small.putImageData(particle.imageDataSmall, 0, 0);
				} else {
					renderParticle(canvas, particle, targetImg);
					renderParticle(canvas_small, particle);
					// Save image
					particle.imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
					particle.imageDataSmall = ctx_small.getImageData(0, 0, canvas_small.width, canvas_small.height);
				}

				// Update UI
				console.log('------------------------------');
				for (var propname in propDisplays) {
					propDisplays[propname].setValue(particle[propname]);
					console.log(propname + ': ' + particle[propname]);
				}
			}

			function findBestInGen(prop, genIndex, mustBeFinished) {
				var bestscore = -Infinity;
				var besti = -1;
				var particles = particleHistory[genIndex];
				for (var i = 0; i < particles.length; i++) {
					var p = particles[i];
					if ((!mustBeFinished || !p.active) && p[prop] > bestscore) {
						bestscore = p[prop];
						besti = i;
					}
				}
				return besti;
			}

			function makeShowBestInGen(prop) {
				return function() {
					var besti = findBestInGen(prop, guistate.generationIndex);
					particleSlider.setValue(besti);
				}
			}

			function findBestOverall(prop, mustBeFinished) {
				var bestscore = -Infinity;
				var besti = -1;
				var bestj = -1;
				for (var i = 0; i < particleHistory.length; i++) {
					var j = findBestInGen(prop, i, mustBeFinished);
					if (j !== -1) {  // mustBeFinished && all particles this gen are active
						var p = particleHistory[i][j];
						if ((!mustBeFinished || !p.active) && p[prop] > bestscore) {
							bestscore = p[prop];
							besti = i;
							bestj = j;
						}
					}
				}
				return {generationIndex: besti, particleIndex: bestj};
			}

			function makeShowBestOverall(prop) {
				return function() {
					var best = findBestOverall(prop);
					generationSlider.setValue(best.generationIndex);
					particleSlider.setValue(best.particleIndex);
				}
			}

			function makeShowBestOverallFinished(prop) {
				return function() {
					var best = findBestOverall(prop, true);
					generationSlider.setValue(best.generationIndex);
					particleSlider.setValue(best.particleIndex);
				}
			}

			// Arrow keys also allow navigation
			var LEFT_ARROW = 37;
			var UP_ARROW = 38;
			var RIGHT_ARROW = 39;
			var DOWN_ARROW = 40;
			function keyEvent(event) {
				var key = event.keyCode || event.which;
				if (particleHistory) {
					if (key === LEFT_ARROW) {
						var pindex = Math.max(guistate.particleIndex - 1, 0);
						particleSlider.setValue(pindex);
					} else if (key === RIGHT_ARROW) {
						var pindex = Math.min(guistate.particleIndex + 1, numParticles - 1);
						particleSlider.setValue(pindex);
					} else if (key === DOWN_ARROW) {
						var gindex = Math.max(guistate.generationIndex - 1, 0);
						generationSlider.setValue(gindex);
					} else if (key === UP_ARROW) {
						var gindex = Math.min(guistate.generationIndex + 1, particleHistory.length - 1);
						generationSlider.setValue(gindex);
					}
				}
			}

			function loadTargetImages(basename, callback) {
				var targetImgFile = '../targets/source/' + basename + '.png';
				var smallTargetImgFile = '../targets/training/' + basename + '.png';
				targetImg = new Image();
				targetImg.addEventListener('load', function() {
					var bigCanvas = $('#canvas').length ? $('#canvas') : $('<canvas/>', {id: 'canvas'}).appendTo('body');
					bigCanvas.prop({width: targetImg.width, height: targetImg.height});

					smallTargetImg = new Image();
					smallTargetImg.addEventListener('load', function() {
						var smallCanvas = $('#canvas-small').length ? $('#canvas-small') : $('<canvas/>', {id: 'canvas-small'}).appendTo('body');
						smallCanvas.prop({width: smallTargetImg.width, height: smallTargetImg.height});

						// Hidden WebGL canvas
						var glCanvas = $('#canvas-gl').length ? $('#canvas-gl') : $('<canvas/>', {id: 'canvas-gl'}).appendTo('body');
						glCanvas.prop({width: targetImg.width, height: targetImg.height});
						glCanvas.css('display', 'none');

						callback();
					}, false);
					smallTargetImg.src = smallTargetImgFile;
				}, false);
				targetImg.src = targetImgFile;
			}

			function computePropRange(history, prop) {
				var minval = Infinity;
				var maxval = -Infinity;
				for (var i = 0; i < history.length; i++) {
					var ps = history[i];
					for (var j = 0; j < ps.length; j++) {
						var p = ps[j];
						minval = Math.min(minval, p[prop]);
						maxval = Math.max(maxval, p[prop]);
					}
				}
				return {min: minval, max: maxval};
			}

			function generate() {
				console.log('------------------------------');
				console.log('Generating...');
				$.getJSON('generate', function(data) {
					// Process data
					console.log('   Received data; processing...');
					particleHistory = particleHistoryUtils.decompress(data.history);
					numParticles = particleHistory[0].length;
					viewport = data.viewport;
					loadTargetImages(data.targetName, function() {
						// GUI init
						if (!gui) {
							gui = new dat.GUI();
						} else {
							for (var i = 0; i < guicomponents.length; i++)
								gui.remove(guicomponents[i]);
						}
						guistate = {
							generationIndex: particleHistory.length - 1,
							particleIndex: findBestInGen('log_post', particleHistory.length - 1),
							LPshowBestInGen: makeShowBestInGen('log_post'),
							LPshowBestOverall: makeShowBestOverall('log_post'),
							LPshowBestOverallFinished: makeShowBestOverallFinished('log_post'),
							LLshowBestInGen: makeShowBestInGen('log_like'),
							LLshowBestOverall: makeShowBestOverall('log_like'),
							LLshowBestOverallFinished: makeShowBestOverallFinished('log_like'),
						}

						// Sliders for controlling which generation/particle we're looking at.
						generationSlider = gui.add(guistate, 'generationIndex', 0, particleHistory.length-1).step(1).name('Generation');
						generationSlider.onChange(showCurrentParticle);
						particleSlider = gui.add(guistate, 'particleIndex', 0, particleHistory[0].length-1).step(1).name('Particle');
						particleSlider.onChange(showCurrentParticle);
						guicomponents = [generationSlider, particleSlider];

						// Particle properties that we want to display.
						var particleProps = [
							{name: 'num_branches'},
							{name: 'log_prior'},
							{name: 'log_like'},
							{name: 'log_post'},
							{name: 'similarity', range: {min: 0, max: 1}},
							{name: 'active'}
						];
						var currparticle = particleHistory[guistate.generationIndex][guistate.particleIndex];
						propDisplays = {};
						function formatname(name, type) {
							var ret = name.split('_').map(function(word) {
								return word.charAt(0).toUpperCase() + word.slice(1); // capitalize
							}).join(' ');
							if (type === 'boolean') { ret += '?'; }
							return ret;
						}
						for (var i = 0; i < particleProps.length; i++) {
							var prop = particleProps[i];
							var propval = currparticle[prop.name];
							guistate[prop.name] = propval;
							var proptype = typeof(propval);
							var displayName = formatname(prop.name, proptype);
							var displayWidget;
							if (proptype === 'boolean') {
								displayWidget = gui.add(guistate, prop.name).name(displayName);
							} else if (proptype === 'number') {
								var range = prop.range || computePropRange(particleHistory, prop.name);
								displayWidget = gui.add(guistate, prop.name, range.min, range.max).name(displayName);
							} else {
								throw 'Particle property ' + prop.name + ' has unsupported type ' + proptype +
								'; cannot display';
							}
							propDisplays[prop.name] = displayWidget;
							guicomponents.push(displayWidget);
						}

						// Buttons for jumping directly to 'best' particles.
						var LPbestOverallButton = gui.add(guistate, 'LPshowBestOverall').name('LP Best');
						var LPbestOverallFinishedButton = gui.add(guistate, 'LPshowBestOverallFinished').name('LP Best finished');
						var LPbestInGenButton = gui.add(guistate, 'LPshowBestInGen').name('LP Best in gen');
						var LLbestOverallButton = gui.add(guistate, 'LLshowBestOverall').name('LL Best');
						var LLbestOverallFinishedButton = gui.add(guistate, 'LLshowBestOverallFinished').name('LL Best finished');
						var LLbestInGenButton = gui.add(guistate, 'LLshowBestInGen').name('LL Best in gen');
						guicomponents = guicomponents.concat([LPbestOverallButton, LPbestOverallFinishedButton, LPbestInGenButton,
															  LLbestOverallButton, LLbestOverallFinishedButton, LLbestInGenButton]);

						// Finish up
						console.log('   DONE.');
						showCurrentParticle();
					});
				});
			}

			// The generate button
			$('<button>Generate</button>').css('font-size', '18pt').click(generate).appendTo('body');

		</script>
	</body>
</html>




